一、继承
OOP中，可以从已有的类中派生出新的类，这被称为继承

（一）父类与子类
不同的类也可能会有一些共同的动作和特征，将这些共同的特征和动作都统一放到一个类中

如果类C1扩展自另一个类C2，那么就将C1称为：次类，C2称为：超类

超类：又称父类、基类

次类：又称子类、扩展类或者派生类

子类从它的父类中继承可访问的数据域和方法，还可以添加新的数据域和方法

创建子类需要使用extend
语法：
public class 子类名 extend 父类名

（二）super（父类）
与this相似，super是指这个super出现的类的父类（简单来说，就是指向父类）

1、调用父类的构造方法

super() 或者 super(parameter)

因此提出了一个新的思路：子类可以调用父类的构造方法来实现自己的构造方法

在使用父类的构造方法（super()或者super(parameter)）时，必须将这条语句写在第一行

如果子类的构造方法里面什么也不写，那么会自动调用父类的构造方法

简单来说：
public ClassNamen(){

}
上述写法等价于：
public ClassName(){
super();
}
或者是
public ClassNamen(double d){

}
上述写法等价于：
public ClassName(double d){
super();

}


2、构造方法链：
在任何情况下，构造一个类的实例时，将会调用沿着继承链的所有父类的构造方法。

当构造一个子类的对象时，子类的构造方法会在完成自己的任务之前，首先调用它的父类的构造方法

public class Faculty extends Employee {
	public static void main(String[] args) {
		new Faculty();
	}
	
	public Faculty() {
		System.out.println("(4) Peforms Faculty tasks");
		// TODO 自动生成的构造函数存根
	}
}
class Employee extends Person {
	public Employee() {
		this("(2)Invoke Employee's overloaded constructor");
		System.out.println("(3)Performs Employee's tasks");
		// TODO 自动生成的构造函数存根
	}
	public Employee(String s) {
		//this("(2)Invoke Employee's overloaded constructor")
		System.out.println(s);
		// TODO 自动生成的构造函数存根
	}
}
class Person{
	public Person() {
		System.out.println("(1)Performs Person's tasks");
		// TODO 自动生成的构造函数存根
	}
}
输出：
(1)Performs Person's tasks
(2)Invoke Employee's overloaded constructor
(3)Performs Employee's tasks
(4) Peforms Faculty tasks

3、调用父类方法
super.方法名（参数）

4、覆盖方法
有时子类需要修改从父类那里继承的方法，不需要更改方法名，直接建立一个同名的方法（有点像类变量与局部变量的关系）
由于父类与子类都有同名方法，如果想调用父类的：
super.方法名（参数）


5、重载方法
子类如果要重载父类的方法，修饰符和返回类型必须相同，参数列表不同

覆盖于重载的区别：
（1）覆盖：子类的方法头与父类的方法头一模一样，连参数列表都相同，但是方法体不同
（2）重载：子类的修饰符、返回值类型与父类的方法一样，但是参数列表不一样

当子类使用与父类相同名字的方法时：
（1）覆盖：使用子类的方法
（2）重载：根据参数，决定使用子类的方法还是父类的方法

（三）Object类（java.lang.Object类）
Java中的所有类都源于Object类，如果在定义一个类时，没有说明父类，那就默认是Object类

1、toString()方法
toString()方法的签名（方法头）
public String toString();

调用一个对象的toString()会返回一个描述该对象的字符串，默认情况下：
所属类名+at符号+该对象十六进制形式的内存地址


二、多态
每个子类的实例都是其父类的实例

子类是父类的特殊化

一个方法可以在父类定义而在它的子类覆盖

1、声明类型与实际类型
Object o = new GeometricObject;
o的声明类型是Object，但是它的实际类型是GeometricObject；
o所调用的方法由它的实际类型决定
